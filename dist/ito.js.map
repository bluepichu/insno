{"version":3,"sources":["ito.ts","ito.js"],"names":[],"mappings":"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","file":"ito.js","sourcesContent":["\"use strict\";\n\nenum RecongizerResponse {\n\tACCEPT,\n\tREJECT,\n\tWAIT\n}\n\nconst ACCEPT = RecongizerResponse.ACCEPT;\nconst REJECT = RecongizerResponse.REJECT;\nconst WAIT = RecongizerResponse.WAIT;\n\ntype RecognizerMatcher = (event: TouchEvent, state: any) => RecongizerResponse;\n\ninterface Recognizer {\n\tmatch: RecognizerMatcher;\n\tnext: GestureNode;\n}\n\nclass GestureGraph {\n\tprivate _element: Element;\n\tprivate _nodes: { [key: string]: GestureNode }; // TODO(bluepichu): Replace with ES6 map when support is good\n\tprivate _clearNode: GestureNode;\n\tprivate _startNode: GestureNode;\n\tprivate _currentNode: GestureNode;\n\tprivate _listeners: { [key: string]: ((arg?: any) => void)[] };\n\n\tpublic state: any;\n\n\tpublic constructor(element: Element) {\n\t\tthis._element = element;\n\t\tthis._nodes = {};\n\t\tthis._clearNode = new GestureNode(this);\n\t\tthis._startNode =\n\t\t\tthis._clearNode.then((event) => event.type === \"touchend\" && event.touches.length === 0 ? ACCEPT : WAIT);\n\t\tthis._currentNode = undefined;\n\t\tthis._listeners = {};\n\n\t\tthis.state = {};\n\t}\n\n\tprivate handleTouch(event: TouchEvent): void {\n\t\tthis._currentNode.handleTouch(event);\n\t\tevent.preventDefault();\n\t}\n\n\tpublic start(node?: GestureNode | string): GestureNode {\n\t\tlet start: GestureNode = undefined;\n\n\t\tif (node !== undefined) {\n\t\t\tstart = this.getNode(node);\n\t\t} else {\n\t\t\tstart = this._startNode;\n\t\t}\n\n\t\tif (start === undefined) {\n\t\t\tthrow new Error(`Ito Error: illegal state`);\n\t\t}\n\n\t\treturn start;\n\t}\n\n\tpublic setNodeName(node: GestureNode, name: string): void {\n\t\tif (name in this._nodes) {\n\t\t\tthrow new Error(`Ito Error: GestureNode with name \"${name}\" already exists`);\n\t\t}\n\n\t\tthis._nodes[name] = node;\n\t}\n\n\tpublic moveToNode(node: GestureNode | string): void {\n\t\tthis._currentNode = this.getNode(node);\n\t\tthis._currentNode.enter();\n\t}\n\n\tprivate getNode(node: GestureNode | string): GestureNode {\n\t\tif (typeof node === \"string\") {\n\t\t\tif (node in this._nodes) {\n\t\t\t\treturn this._nodes[node];\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Ito Error: node with name \"${node}\" not found`);\n\t\t\t}\n\t\t} else {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\tpublic reset(): void {\n\t\tthis.moveToNode(this._startNode);\n\t}\n\n\tpublic fire(events: [string, any][]): void {\n\t\tevents.forEach(([event, arg]) => {\n\t\t\tif (event in this._listeners) {\n\t\t\t\tthis._listeners[event].forEach((listener) => {\n\t\t\t\t\tlistener(arg);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic addEventListener(event: string, listener: () => void) {\n\t\tif (!(event in this._listeners)) {\n\t\t\tthis._listeners[event] = [];\n\t\t}\n\n\t\tthis._listeners[event].push(listener);\n\t}\n\n\tpublic listen(): void {\n\t\tif (this._currentNode !== undefined) {\n\t\t\tthrow new Error(`Ito Error: this instance is already listening`);\n\t\t}\n\n\t\tlet handler = this.handleTouch.bind(this);\n\n\t\tthis._element.addEventListener(\"touchstart\", handler);\n\t\tthis._element.addEventListener(\"touchend\", handler);\n\t\tthis._element.addEventListener(\"touchmove\", handler);\n\n\t\tthis.reset();\n\t}\n\n\tpublic wait(): void {\n\t\tthis.moveToNode(this._clearNode);\n\t}\n}\n\nclass GestureNode {\n\tprivate _parent: GestureGraph;\n\tprivate _name: string | void;\n\tprivate _events: (string | ((state: any) => string) | ((state: any) => [string, any]))[];\n\tprivate _recognizers: Recognizer[];\n\tprivate _timeout: { time: number, next: GestureNode };\n\tprivate _currentRecognizers: Recognizer[];\n\tprivate _currentTimeout: number;\n\tprivate _goto: GestureNode | string | void;\n\n\tpublic constructor(parent: GestureGraph) {\n\t\tthis._parent = parent;\n\t\tthis._name = undefined;\n\t\tthis._events = [];\n\t\tthis._recognizers = [];\n\t\tthis._timeout = undefined;\n\t\tthis._currentRecognizers = undefined;\n\t\tthis._currentTimeout = undefined;\n\t\tthis._goto = undefined;\n\t}\n\n\tpublic name(name: string): GestureNode {\n\t\tif (this._name !== undefined) {\n\t\t\tthrow new Error(`Ito Error: GestureNode \"${this._name}\" is already named and cannot be renamed`);\n\t\t}\n\n\t\tthis._parent.setNodeName(this, name);\n\t\tthis._name = name;\n\n\t\treturn this;\n\t}\n\n\tpublic fire(evt: string | ((state: any) => string) | ((state: any) => [string, any])): GestureNode {\n\t\tthis._events.push(evt);\n\n\t\treturn this;\n\t}\n\n\tpublic then(matcher: RecognizerMatcher): GestureNode {\n\t\tlet next = new GestureNode(this._parent);\n\n\t\tthis._recognizers.push({\n\t\t\tmatch: matcher,\n\t\t\tnext: next\n\t\t});\n\n\t\treturn next;\n\t}\n\n\tpublic timeout(time: number): GestureNode {\n\t\tlet next = new GestureNode(this._parent);\n\n\t\tthis._timeout = {\n\t\t\ttime: time,\n\t\t\tnext: next\n\t\t};\n\n\t\treturn next;\n\t}\n\n\tpublic enter(): void {\n\t\tlet events: [string, any][] = this._events.map((event) => {\n\t\t\tif (typeof event === \"string\") {\n\t\t\t\treturn [event, undefined] as [string, any];\n\t\t\t} else {\n\t\t\t\tlet res = event(this._parent.state);\n\n\t\t\t\tif (Array.isArray(res)) {\n\t\t\t\t\treturn res as [string, any];\n\t\t\t\t} else {\n\t\t\t\t\treturn [res, undefined] as [string, any];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis._parent.fire(events);\n\n\t\tif (this._goto !== undefined) {\n\t\t\tthis._parent.moveToNode(this._goto as GestureNode | string);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentRecognizers = this._recognizers.slice();\n\n\t\tif (this._timeout !== undefined) {\n\t\t\tthis._currentTimeout = setTimeout(() => this.advanceTo(this._timeout.next), this._timeout.time);\n\t\t}\n\n\t\tif (this._currentRecognizers.length === 0 && this._timeout === undefined) {\n\t\t\tthis.wait();\n\t\t}\n\t}\n\n\tpublic handleTouch(event: TouchEvent): void {\n\t\tclearTimeout(this._currentTimeout);\n\n\t\tfor (let i = 0; i < this._currentRecognizers.length; i++) {\n\t\t\tswitch (this._currentRecognizers[i].match(event, this._parent.state)) {\n\t\t\t\tcase ACCEPT:\n\t\t\t\t\tthis.advanceTo(this._currentRecognizers[i].next);\n\t\t\t\t\treturn;\n\n\t\t\t\tcase REJECT:\n\t\t\t\t\tthis._currentRecognizers.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WAIT:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Ito Error: invalid return from matcher (not ACCEPT, REJECT, or WAIT)`);\n\t\t\t}\n\t\t}\n\n\t\tif (this._currentRecognizers.length === 0) {\n\t\t\tthis.wait();\n\t\t}\n\t}\n\n\tprivate wait(): void {\n\t\tclearTimeout(this._currentTimeout);\n\t\tthis._parent.wait();\n\t}\n\n\tprivate advanceTo(node: GestureNode): void {\n\t\tclearTimeout(this._currentTimeout);\n\t\tthis._currentRecognizers = undefined;\n\t\tthis._currentTimeout = undefined;\n\t\tthis._parent.moveToNode(node);\n\t}\n\n\tpublic goto(node: GestureNode | string): void {\n\t\tthis._goto = node;\n\t}\n}\n\nclass Ito extends GestureGraph {\n\tstatic ACCEPT = ACCEPT;\n\tstatic REJECT = REJECT;\n\tstatic WAIT = WAIT;\n}","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar RecongizerResponse;\n(function (RecongizerResponse) {\n    RecongizerResponse[RecongizerResponse[\"ACCEPT\"] = 0] = \"ACCEPT\";\n    RecongizerResponse[RecongizerResponse[\"REJECT\"] = 1] = \"REJECT\";\n    RecongizerResponse[RecongizerResponse[\"WAIT\"] = 2] = \"WAIT\";\n})(RecongizerResponse || (RecongizerResponse = {}));\nvar ACCEPT = RecongizerResponse.ACCEPT;\nvar REJECT = RecongizerResponse.REJECT;\nvar WAIT = RecongizerResponse.WAIT;\nvar GestureGraph = (function () {\n    function GestureGraph(element) {\n        this._element = element;\n        this._nodes = {};\n        this._clearNode = new GestureNode(this);\n        this._startNode =\n            this._clearNode.then(function (event) { return event.type === \"touchend\" && event.touches.length === 0 ? ACCEPT : WAIT; });\n        this._currentNode = undefined;\n        this._listeners = {};\n        this.state = {};\n    }\n    GestureGraph.prototype.handleTouch = function (event) {\n        this._currentNode.handleTouch(event);\n        event.preventDefault();\n    };\n    GestureGraph.prototype.start = function (node) {\n        var start = undefined;\n        if (node !== undefined) {\n            start = this.getNode(node);\n        }\n        else {\n            start = this._startNode;\n        }\n        if (start === undefined) {\n            throw new Error(\"Ito Error: illegal state\");\n        }\n        return start;\n    };\n    GestureGraph.prototype.setNodeName = function (node, name) {\n        if (name in this._nodes) {\n            throw new Error(\"Ito Error: GestureNode with name \\\"\" + name + \"\\\" already exists\");\n        }\n        this._nodes[name] = node;\n    };\n    GestureGraph.prototype.moveToNode = function (node) {\n        this._currentNode = this.getNode(node);\n        this._currentNode.enter();\n    };\n    GestureGraph.prototype.getNode = function (node) {\n        if (typeof node === \"string\") {\n            if (node in this._nodes) {\n                return this._nodes[node];\n            }\n            else {\n                throw new Error(\"Ito Error: node with name \\\"\" + node + \"\\\" not found\");\n            }\n        }\n        else {\n            return node;\n        }\n    };\n    GestureGraph.prototype.reset = function () {\n        this.moveToNode(this._startNode);\n    };\n    GestureGraph.prototype.fire = function (events) {\n        var _this = this;\n        events.forEach(function (_a) {\n            var event = _a[0], arg = _a[1];\n            if (event in _this._listeners) {\n                _this._listeners[event].forEach(function (listener) {\n                    listener(arg);\n                });\n            }\n        });\n    };\n    GestureGraph.prototype.addEventListener = function (event, listener) {\n        if (!(event in this._listeners)) {\n            this._listeners[event] = [];\n        }\n        this._listeners[event].push(listener);\n    };\n    GestureGraph.prototype.listen = function () {\n        if (this._currentNode !== undefined) {\n            throw new Error(\"Ito Error: this instance is already listening\");\n        }\n        var handler = this.handleTouch.bind(this);\n        this._element.addEventListener(\"touchstart\", handler);\n        this._element.addEventListener(\"touchend\", handler);\n        this._element.addEventListener(\"touchmove\", handler);\n        this.reset();\n    };\n    GestureGraph.prototype.wait = function () {\n        this.moveToNode(this._clearNode);\n    };\n    return GestureGraph;\n}());\nvar GestureNode = (function () {\n    function GestureNode(parent) {\n        this._parent = parent;\n        this._name = undefined;\n        this._events = [];\n        this._recognizers = [];\n        this._timeout = undefined;\n        this._currentRecognizers = undefined;\n        this._currentTimeout = undefined;\n        this._goto = undefined;\n    }\n    GestureNode.prototype.name = function (name) {\n        if (this._name !== undefined) {\n            throw new Error(\"Ito Error: GestureNode \\\"\" + this._name + \"\\\" is already named and cannot be renamed\");\n        }\n        this._parent.setNodeName(this, name);\n        this._name = name;\n        return this;\n    };\n    GestureNode.prototype.fire = function (evt) {\n        this._events.push(evt);\n        return this;\n    };\n    GestureNode.prototype.then = function (matcher) {\n        var next = new GestureNode(this._parent);\n        this._recognizers.push({\n            match: matcher,\n            next: next\n        });\n        return next;\n    };\n    GestureNode.prototype.timeout = function (time) {\n        var next = new GestureNode(this._parent);\n        this._timeout = {\n            time: time,\n            next: next\n        };\n        return next;\n    };\n    GestureNode.prototype.enter = function () {\n        var _this = this;\n        var events = this._events.map(function (event) {\n            if (typeof event === \"string\") {\n                return [event, undefined];\n            }\n            else {\n                var res = event(_this._parent.state);\n                if (Array.isArray(res)) {\n                    return res;\n                }\n                else {\n                    return [res, undefined];\n                }\n            }\n        });\n        this._parent.fire(events);\n        if (this._goto !== undefined) {\n            this._parent.moveToNode(this._goto);\n            return;\n        }\n        this._currentRecognizers = this._recognizers.slice();\n        if (this._timeout !== undefined) {\n            this._currentTimeout = setTimeout(function () { return _this.advanceTo(_this._timeout.next); }, this._timeout.time);\n        }\n        if (this._currentRecognizers.length === 0 && this._timeout === undefined) {\n            this.wait();\n        }\n    };\n    GestureNode.prototype.handleTouch = function (event) {\n        clearTimeout(this._currentTimeout);\n        for (var i = 0; i < this._currentRecognizers.length; i++) {\n            switch (this._currentRecognizers[i].match(event, this._parent.state)) {\n                case ACCEPT:\n                    this.advanceTo(this._currentRecognizers[i].next);\n                    return;\n                case REJECT:\n                    this._currentRecognizers.splice(i, 1);\n                    i--;\n                    break;\n                case WAIT:\n                    break;\n                default:\n                    throw new Error(\"Ito Error: invalid return from matcher (not ACCEPT, REJECT, or WAIT)\");\n            }\n        }\n        if (this._currentRecognizers.length === 0) {\n            this.wait();\n        }\n    };\n    GestureNode.prototype.wait = function () {\n        clearTimeout(this._currentTimeout);\n        this._parent.wait();\n    };\n    GestureNode.prototype.advanceTo = function (node) {\n        clearTimeout(this._currentTimeout);\n        this._currentRecognizers = undefined;\n        this._currentTimeout = undefined;\n        this._parent.moveToNode(node);\n    };\n    GestureNode.prototype.goto = function (node) {\n        this._goto = node;\n    };\n    return GestureNode;\n}());\nvar Ito = (function (_super) {\n    __extends(Ito, _super);\n    function Ito() {\n        _super.apply(this, arguments);\n    }\n    Ito.ACCEPT = ACCEPT;\n    Ito.REJECT = REJECT;\n    Ito.WAIT = WAIT;\n    return Ito;\n}(GestureGraph));\n"],"sourceRoot":"/source/"}